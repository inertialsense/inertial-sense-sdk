#include <gtest/gtest.h>
#include <deque>
#include "ISComm.h"
#include "ring_buffer.h"
#include "protocol_nmea.h"

#if 0
extern "C"
{
#include "../../../libs-int/rtklib/src/rtklib.h"
	extern gtime_t g_gps_latest_time;
	extern int decode_rtcm3(rtcm_t *rtcm);
	extern int decode_ubx(raw_t* raw);
}
#endif

// Tests
#define BASIC_TX_BUFFER_RX_BYTE_TEST         	1
#define BASIC_TX_PORT_RX_BYTE_TEST           	1
#define BASIC_TX_RX_MULTI_BYTE_TEST          	1
#define TXRX_MULTI_BYTE_PRECEEDED_BY_GARBAGE 	1
#define TXRX_WITH_OFFSET_TEST                	1
#define SEGMENTED_RX_TEST                    	1
#define BLAST_RX_TEST                        	1
#define TEST_ALTERNATING_ISB_NMEA_PARSE_ERRORS  1
#define TEST_TRUNCATED_PACKETS                  1
#define TEST_BUFF_PARSE_MSG						1

#define TEST_STATS_FOR_NERDS                    0

// Protocols
#define TEST_PROTO_ISB		1
#define TEST_PROTO_NMEA		1
#define TEST_PROTO_SONY		1
#define TEST_PROTO_UBLOX	1
#define TEST_PROTO_RTCM3	1
#define TEST_PROTO_SPARTN	0

#if 0
#define DEBUG_PRINTF	printf
#else
#define DEBUG_PRINTF	
#endif

#define PORT_BUFFER_SIZE	10000

typedef struct
{
	struct 
	{
		dev_info_t			devInfo;
		nvm_flash_cfg_t		nvmFlashCfg;
		nmea_msgs_t			nmeaMsgs;
	}						msgs = { 0 };

	// Used to simulate serial ports
	ring_buf_t				portRxBuf;
	uint8_t					portRxBuffer[PORT_BUFFER_SIZE];
	ring_buf_t				portTxBuf;
	uint8_t					portTxBuffer[PORT_BUFFER_SIZE];
} test_data_t;

typedef struct
{
	protocol_type_t	ptype;	// Data start byte
	uint32_t		did;
	union
	{
		uint8_t		buf[PKT_BUF_SIZE];
		uDatasets	set;
	}				data;
	uint32_t		size;		// size of data
	uint32_t		pktSize;	// size of encoded packet (pkt header, data header, data, pkt footer)
} data_holder_t;

static test_data_t tcm = {};
static std::deque<data_holder_t> g_testRxDeque;
static std::deque<data_holder_t> g_testTxDeque;

static int portRead(int pHandle, unsigned char* buf, int len)
{
	return ringBufRead(&tcm.portRxBuf, buf, len);
}

static int portWrite(unsigned int pHandle, const unsigned char* buf, int len)
{
	if (ringBufWrite(&tcm.portTxBuf, (unsigned char*)buf, len))
	{	// Buffer overflow
		DEBUG_PRINTF("tcm.portTxBuf ring buffer overflow: %d !!!\n", ringBufUsed(&tcm.portTxBuf) + len);
		EXPECT_TRUE(false);
	}
	return len;
}

// return 1 on success, 0 on failure
int msgHandlerNmea2(int pHandle, const uint8_t* msg, int msgSize)
{
// 	comWrite(pHandle, line, lineLength); // echo back
// 	time_delay_msec(50); // give time for the echo to come back

	if (msgSize == 10)
	{	// 4 character commands (i.e. "$STPB*14\r\n")
		switch (getNmeaMsgId(msg, msgSize))
		{
		case NMEA_MSG_ID_ASCE:	// query NMEA message broadcast rates
		// 		writeNmeaBcastPeriod(cmHandle, pHandle, NULLPTR);
			break;

		case NMEA_MSG_ID_STPB: // stop all broadcasts on all ports
			// disableBroadcasts(cmHandle, -1);
			break;

		case NMEA_MSG_ID_STPC: // stop all broadcasts on current port
			// disableBroadcasts(cmHandle, pHandle);
			break;

		case NMEA_MSG_ID_BLEN: // bootloader enable
			break;

		case NMEA_MSG_ID_SRST: // soft reset
			break;

		case NMEA_MSG_ID_INFO: // query device version information
			break;

		case NMEA_MSG_ID_PERS: // Save persistent messages to flash memory
			break;
		}
	}
	else
	{	// General NMEA messages
		//switch (messageIdUInt)
		//{
		//default:
		//	break;
		//}
	}

	data_holder_t td = g_testRxDeque.front();
	g_testRxDeque.pop_front();
	uint8_t buf[30] = {};
	memcpy(buf, msg, (msgSize<29?msgSize:29));
	DEBUG_PRINTF("[%2d] asciiMessageHandler() size: %3d, %.30s...\n", (int)g_testRxDeque.size(), msgSize, buf);

	EXPECT_EQ(td.size, msgSize);
	EXPECT_TRUE(memcmp(&td.data, msg, td.size) == 0);

	return 0;
}

static int msgHandlerUblox2(int pHandle, const uint8_t* msg, int msgSize)
{
	data_holder_t td = g_testRxDeque.front();
	g_testRxDeque.pop_front();
	DEBUG_PRINTF("[%2d] ubloxMessageHandler() size: %3d, (0x%02x 0x%02x)\n", (int)g_testRxDeque.size(), msgSize, msg[2], msg[3]);

	EXPECT_EQ(td.size, msgSize);
	EXPECT_TRUE(memcmp(&td.data, msg, td.size) == 0);

	return 0;
}

static int msgHandlerRtcm32(int pHandle, const uint8_t* msg, int msgSize)
{
	data_holder_t td = g_testRxDeque.front();
	g_testRxDeque.pop_front();
	DEBUG_PRINTF("[%2d] rtcm3MessageHandler() size: %3d, (0x%02x 0x%02x 0x%02x 0x%02x)\n", (int)g_testRxDeque.size(), msgSize, msg[0], msg[1], msg[2], msg[3]);

	EXPECT_EQ(td.size, msgSize);
	EXPECT_TRUE(memcmp(&td.data, msg, td.size) == 0);

#if 0
	rtcm_t raw = {};
	obsd_t obsData[100];
	raw.obs.data = obsData;
	raw.obs.nmax = raw.obs.n = 100;
	raw.buff = (unsigned char*)msg;
	raw.len = msgSize;

	int j = 0;
	switch (decode_rtcm3(&raw))
	{
	case DATA_TYPE_OBSERVATION:
	case DATA_TYPE_EPHEMERIS:
	case DATA_TYPE_SBS:
	case DATA_TYPE_ANTENNA_POSITION:
	case DATA_TYPE_ION_UTC_ALMANAC:
		j = 2;
		break;

	default:
	case DATA_TYPE_ERROR:
		j = 5;
		break;
	}
#endif

	return 0;
}

static void printNmeaMessage(const char *name, const uint8_t* str, int size)
{
	DEBUG_PRINTF("%s: ", name);
	for (int i=0; i<size && str[i]!='\r' && str[i]!='\n'; i++)
	{
		DEBUG_PRINTF("%c", str[i]);
		if (i==30) { DEBUG_PRINTF("..."); break; }
	}
	DEBUG_PRINTF("\n");
}

static is_comm_instance_t g_comm;
#define COM_BUFFER_SIZE 4096
static uint8_t g_comm_buffer[COM_BUFFER_SIZE] = {0};


static bool init(test_data_t &t)
{
	// Init Port Buffers
	ringBufInit(&(t.portTxBuf), t.portTxBuffer, sizeof(t.portTxBuffer), 1);
	ringBufInit(&(t.portRxBuf), t.portRxBuffer, sizeof(t.portRxBuffer), 1);

	is_comm_init(&g_comm, g_comm_buffer, COM_BUFFER_SIZE);

	// Enable/disable protocols
	g_comm.config.enabledMask = 0;
	g_comm.config.enabledMask |= (uint32_t)(ENABLE_PROTOCOL_ISB    * TEST_PROTO_ISB);
	g_comm.config.enabledMask |= (uint32_t)(ENABLE_PROTOCOL_NMEA   * TEST_PROTO_NMEA);
	g_comm.config.enabledMask |= (uint32_t)(ENABLE_PROTOCOL_RTCM3  * TEST_PROTO_RTCM3);
	g_comm.config.enabledMask |= (uint32_t)(ENABLE_PROTOCOL_SONY   * TEST_PROTO_SONY);
	g_comm.config.enabledMask |= (uint32_t)(ENABLE_PROTOCOL_SPARTN * TEST_PROTO_SPARTN);
	g_comm.config.enabledMask |= (uint32_t)(ENABLE_PROTOCOL_UBLOX  * TEST_PROTO_UBLOX);

	return true;
}

// Returns false when buffer is full
static bool generateDataAppend(std::deque<data_holder_t> &testDeque, data_holder_t &td, int &byteSize)
{
	if (td.size==0)
	{
		return true;
	}

	if (byteSize + td.size < (PORT_BUFFER_SIZE*9)/10)	// Allow room for packet headers
	{
		byteSize += td.size;

		// Add data to deque
		testDeque.push_back(td);
	}
	else
	{	// Buffer is full
		return false;
	}

	DEBUG_PRINTF("[%2d] ", (int)testDeque.size()-1);
	switch (td.ptype)
	{
	case _PTYPE_INERTIAL_SENSE_DATA:
	case _PTYPE_INERTIAL_SENSE_CMD:
		DEBUG_PRINTF("DID: %3d, size: %3d\n", td.did, td.size);
		break;
	case _PTYPE_NMEA:
		printNmeaMessage("NMEA", td.data.buf, td.size);
		break;
	case _PTYPE_UBLOX:
		DEBUG_PRINTF("UBLOX: size %d, (0x%02x 0x%02x)\n", td.size, td.data.buf[2], td.data.buf[3]);
		break;
	case _PTYPE_RTCM3:
		DEBUG_PRINTF("RTCM3: size %d, (%02x %02x %02x %02x)\n", td.size, td.data.buf[0], td.data.buf[1], td.data.buf[2], td.data.buf[3]);
		break;
	case _PTYPE_SONY:
		DEBUG_PRINTF("Sony: size %d, (OPC 0x%02x)\n", td.size, td.data.buf[3]);
		break;
	}

	return true;
}

static void generateData(std::deque<data_holder_t> &testDeque)
{
	testDeque.clear();
	int byteSize = 0;

	DEBUG_PRINTF("===============  generateData()  ===============\n");

	// Generate data and add to test deque
	for (int i = 0; ; i++)
	{
		data_holder_t td = {};
		ins_1_t ins1 = { 0 };
		gps_pos_t gps = { 0 };

		if (i % 16 == 0)
		{	// INS 1
			ins1.timeOfWeek = ((double)i)*0.001;
			ins1.week = i + 100;
			ins1.insStatus = i;
			ins1.hdwStatus = i;
			ins1.theta[0] = i + 0.2f;
			ins1.theta[1] = i - 0.3f;
			ins1.theta[2] = i + 0.4f;
			ins1.uvw[0] = i - 0.5f;
			ins1.uvw[1] = i + 0.6f;
			ins1.uvw[2] = i - 0.7f;
			ins1.lla[0] = 40.330565516;
			ins1.lla[1] = -111.725787806;
			ins1.lla[2] = 1408.565264;
			ins1.ned[0] = i + 1.234f;
			ins1.ned[1] = i - 2.345f;
			ins1.ned[2] = i + 3.456f;

#if TEST_PROTO_ISB
			td.did = DID_INS_1;
			td.ptype = _PTYPE_INERTIAL_SENSE_DATA;
			td.data.set.ins1 = ins1;
			td.size = sizeof(ins_1_t);
			if (!generateDataAppend(testDeque, td, byteSize)) return;
#endif

#if TEST_PROTO_NMEA
			td.ptype = _PTYPE_NMEA;
			td.size = nmea_pins1((char*)td.data.buf, sizeof(td.data.buf), ins1);
			if (!generateDataAppend(testDeque, td, byteSize)) return;
#endif
		}

		if (i % 200 == 0)
		{	// GPS
			gps.timeOfWeekMs = i * 1000;
			gps.week = i * 10;
			gps.status = i;
			gps.ecef[0] = (double)i*1.234;
			gps.ecef[1] = (double)i*2.345;
			gps.ecef[2] = (double)i*3.456;
			gps.lla[0] = (double)i*1.234;
			gps.lla[1] = (double)i*2.345;
			gps.lla[2] = (double)i*3.456;
			gps.hAcc = (float)i;
			gps.cnoMean = (float)i;
			gps.hMSL = (float)i;
			gps.pDop = (float)i;
			gps.towOffset = (double)i*123.4;
			gps.leapS = (uint8_t)i;

#if TEST_PROTO_NMEA
			td.ptype = _PTYPE_NMEA;
			td.size = nmea_gga((char*)td.data.buf, sizeof(td.data.buf), gps);
			if (!generateDataAppend(testDeque, td, byteSize)) return;
#endif

#if TEST_PROTO_ISB
			td.ptype = _PTYPE_INERTIAL_SENSE_DATA;
			td.did = DID_GPS1_POS;
			td.data.set.gpsPos = gps;
			td.size = sizeof(gps_pos_t);
			if (!generateDataAppend(testDeque, td, byteSize)) return;
#endif
		}

		if (i % 120 == 0)
		{
#if TEST_PROTO_NMEA
			// NMEA command - Stop all broadcasts
			td.ptype = _PTYPE_NMEA;
			td.size = snprintf((char*)td.data.buf, PKT_BUF_SIZE, "$STPB*15\r\n");
			if (!generateDataAppend(testDeque, td, byteSize)) return;

			// NMEA command - Stop broadcast on current port
			td.ptype = _PTYPE_NMEA;
			td.size = snprintf((char*)td.data.buf, PKT_BUF_SIZE, "$STPC*14\r\n");
			if (!generateDataAppend(testDeque, td, byteSize)) return;
#endif
		}

#if TEST_PROTO_UBLOX
		if (i % 25 == 0)
		{
			static int j = 0;
			switch (j++)
			{
			default: j = 0;	// fall-through
			case 0: {	// Ublox - UBX-NAV-POSLLH (0x01 0x02)
				td.ptype = _PTYPE_UBLOX;
				uint8_t buf[] = { 0xb5,0x62,0x1,0x2,0x1c,0x0,0x0,0xa1,0xad,0x10,0x6a,0xff,0x67,0xbd,0xb7,0xf4,0x9,0x18,0x35,0x7e,0x15,0x0,0xe8,0xc5,0x15,0x0,0x4f,0x1,0x0,0x0,0xa8,0x1,0x0,0x0,0x59,0xbc };
				td.size = sizeof(buf);
				memcpy(td.data.buf, buf, td.size);		// < PKT_BUF_SIZE (2048)
				if (!generateDataAppend(testDeque, td, byteSize)) return;
			} break;

			case 1: {	// Ublox - UBX-RXM-RAWX (0x02 0x15)
				td.ptype = _PTYPE_UBLOX;
				uint8_t buf[] = { 0xb5,0x62,0x2,0x15,0xb0,0x3,0x1b,0x2f,0xdd,0x24,0x1b,0x14,0x11,0x41,0x2b,0x8,0x12,0x1d,0x1,0x1,0x82,0x9,0x5d,0x61,0x9b,0x3f,0xab,0xb,0x80,0x41,0x60,0x1a,0xa8,0x8a,0x7c,0x14,0xa5,0x41,0xa8,0x6e,0x9c,0x43,0x1,0x85,0x0,0x0,0xf4,0xfb,0x2c,0x5,0x1,0x8,0xf,0x0,0x39,0xe2,0x7d,0x36,0x68,0xc,0x83,0x41,0x45,0xc6,0xb1,0x7,0x6c,0x6,0xa9,0x41,0xa0,0xe6,0xc,0x44,0x5,0x2,0x0,0x0,0xf4,0xfb,0x25,0x6,0x1,0x8,0x7,0x0,0x56,0x5c,0xa2,0x55,0x34,0x9f,0x70,0x41,0x24,0xe2,0x8b,0xa8,0x50,0xd6,0x95,0x41,0x34,0x1d,0x31,0x45,0x0,0x5,0x0,0x0,0xf4,0xfb,0x30,0x5,0x1,0x8,0x7,0x0,0x1a,0xaa,0xe6,0x47,0x4,0xa7,0x73,0x41,0x5c,0x99,0x57,0xbc,0x8b,0xd1,0x99,0x41,0x96,0xcd,0x25,0xc5,0x0,0x13,0x0,0x0,0xf4,0xfb,0x26,0x5,0x1,0x8,0x7,0x0,0x79,0x9,0xfb,0xf3,0x4a,0x11,0x70,0x41,0x8e,0x98,0x96,0x32,0xe0,0x1b,0x95,0x41,0xb2,0x6,0xcf,0x44,0x0,0x19,0x0,0x0,0xf4,0xfb,0x2c,0x5,0x1,0x8,0x7,0x0,0x28,0x7c,0xed,0xa,0xb2,0xc3,0x73,0x41,0x7e,0x1f,0x51,0xa7,0x37,0xf7,0x99,0x41,0x16,0x48,0x95,0x44,0x2,0x1,0x0,0x0,0xf4,0xfb,0x29,0x5,0x1,0x8,0x7,0x0,0xe6,0x7a,0x56,0x4c,0x6f,0x33,0x6f,0x41,0xbe,0xd9,0x7f,0x82,0x8c,0xd3,0x94,0x41,0x20,0x25,0x5d,0x44,0x6,0x9,0x0,0x5,0xf4,0xfb,0x26,0x5,0x1,0x8,0x7,0x0,0xa9,0x32,0x13,0x58,0xfd,0x3e,0x6e,0x41,0xa7,0x9f,0x32,0xb6,0x77,0x39,0x94,0x41,0x7c,0x44,0x12,0x44,0x6,0x13,0x0,0xa,0xf4,0xfb,0x21,0x7,0x2,0x8,0x7,0x0,0xb,0x37,0x40,0xe6,0x53,0x54,0x74,0x41,0x50,0xb1,0xc8,0x15,0x3b,0xb5,0x9a,0x41,0xeb,0x3f,0x11,0x45,0x2,0x8,0x0,0x0,0xf4,0xfb,0x27,0x5,0x1,0x8,0x7,0x0,0x62,0xb8,0x14,0xb2,0x1a,0xd,0x72,0x41,0x6e,0xb2,0xbc,0x21,0x4,0xb7,0x97,0x41,0x5e,0x39,0xa5,0x44,0x2,0x1a,0x0,0x0,0xf4,0xfb,0x2a,0x5,0x1,0x8,0x7,0x0,0xa2,0xe1,0xa9,0xf7,0x62,0xe1,0x70,0x41,0x44,0x73,0xc5,0xd4,0x2d,0x97,0x96,0x41,0x1,0xff,0xf4,0x44,0x6,0x3,0x0,0xc,0xf4,0xfb,0x2b,0x5,0x1,0x8,0x7,0x0,0x18,0x57,0x42,0xb8,0x58,0x5e,0x73,0x41,0x68,0x95,0x61,0xc0,0x11,0x72,0x99,0x41,0xc2,0xe6,0xcb,0xc4,0x2,0x15,0x0,0x0,0xf4,0xfb,0x2a,0x5,0x1,0x8,0x7,0x0,0x43,0x99,0x17,0x5c,0xb5,0x22,0x72,0x41,0x8,0xc6,0x9b,0x64,0x5f,0x47,0x98,0x41,0x1e,0x2e,0x86,0x45,0x6,0x4,0x0,0xd,0xf4,0xfb,0x26,0x6,0x1,0x8,0x7,0x0,0x20,0xf5,0x6a,0x72,0xd9,0x46,0x77,0x41,0x42,0xe2,0x94,0x2e,0x7d,0x94,0x9e,0x41,0xd5,0xbb,0x3f,0x45,0x2,0x1f,0x0,0x0,0xf4,0xfb,0x23,0x6,0x1,0x8,0x7,0x0,0x74,0x1,0x2f,0x4d,0x45,0x5f,0x71,0x41,0x2c,0xa5,0xec,0x21,0xb2,0x28,0x97,0x41,0x5b,0x67,0x27,0x45,0x6,0xff,0x0,0x1,0xc0,0x12,0x27,0x5,0x1,0x8,0xf,0x0,0x7,0x49,0x2b,0x5d,0x78,0x3d,0x76,0x41,0x8,0xff,0xb7,0x8e,0xd8,0x37,0x9d,0x41,0xa4,0xc2,0xfa,0xc4,0x2,0xf,0x0,0x0,0xf4,0xfb,0x25,0x5,0x1,0x8,0x7,0x0,0x37,0x34,0x4e,0x78,0xb4,0xe,0x72,0x41,0xe5,0x50,0xde,0xfc,0x1e,0xb9,0x97,0x41,0x33,0xd4,0x35,0x45,0x0,0x1d,0x0,0x0,0xf4,0xfb,0x29,0x5,0x1,0x8,0x7,0x0,0x7b,0x1e,0x56,0x93,0xc0,0x37,0x72,0x41,0x95,0x61,0x9f,0xee,0xa,0xef,0x97,0x41,0xec,0x17,0x2a,0xc5,0x0,0x6,0x0,0x0,0xf4,0xfb,0x2a,0x5,0x1,0x8,0xf,0x0,0xe4,0x3e,0x36,0xf9,0x6,0xdf,0x7f,0x41,0xf5,0x4a,0xe7,0xa1,0x7e,0xef,0xa4,0x41,0x20,0xe0,0x9a,0x43,0x1,0x8a,0x0,0x0,0xf4,0xfb,0x2b,0x5,0x1,0x8,0xf,0x0,0xd,0xbd,0xcc,0xd2,0xc6,0xcd,0x72,0x41,0x9c,0x48,0x6a,0x1c,0x24,0xb4,0x98,0x41,0xd8,0xdd,0x5e,0xc4,0x2,0xd,0x0,0x0,0xf4,0xfb,0x28,0x5,0x1,0x8,0x7,0x0,0xaa,0x1b,0x81,0x57,0xb1,0x3f,0x74,0x41,0x4c,0xe0,0x4e,0x1e,0x1e,0x9a,0x9a,0x41,0xa9,0x3b,0x25,0xc5,0x0,0x18,0x0,0x0,0xf4,0xfb,0x24,0x6,0x1,0x8,0xf,0x0,0x22,0x41,0x5e,0xea,0xaf,0x9f,0x70,0x41,0xcb,0x9f,0xa7,0x62,0x45,0x33,0x96,0x41,0xe0,0xe9,0x5a,0xc5,0x6,0x10,0x0,0x6,0xf4,0xfb,0x24,0x6,0x1,0x8,0xf,0x0,0xce,0x25,0x25,0xa7,0xcf,0x6f,0x70,0x41,0x4e,0x82,0x95,0x5c,0xc,0x98,0x95,0x41,0x8e,0x1c,0x91,0xc4,0x0,0x2,0x0,0x0,0xf4,0xfb,0x2c,0x5,0x1,0x8,0x7,0x0,0x15,0x97,0x78,0xd7,0x1c,0x13,0x72,0x41,0x93,0xcc,0x58,0x82,0xc9,0x1c,0x98,0x41,0xae,0x75,0xae,0xc4,0x6,0x2,0x0,0x3,0xf4,0xfb,0x2a,0x5,0x1,0x8,0xf,0x0,0x71,0x2d,0xf8,0xb7,0xdd,0x23,0x72,0x41,0xd,0xbb,0xcd,0x6b,0x34,0x40,0x98,0x41,0xe1,0xa1,0x38,0x45,0x6,0x14,0x0,0x9,0xf4,0xfb,0x1e,0x8,0x3,0x8,0xf,0x0,0xba,0x40,0xb0,0xd2,0x7d,0x56,0x76,0x41,0xd7,0x44,0xd7,0xff,0xb7,0x58,0x9d,0x41,0x16,0x2f,0x35,0xc5,0x2,0x1b,0x0,0x0,0xf4,0xfb,0x24,0x5,0x1,0x8,0x7,0x0,0x36,0xb9,0xcd,0x0,0x91,0x19,0x74,0x41,0xf2,0xd,0x57,0x62,0x8,0x68,0x9a,0x41,0x8c,0x29,0xb7,0x44,0x0,0x1f,0x0,0x0,0xf4,0xfb,0x29,0x5,0x1,0x8,0xf,0x0,0xfe,0x54,0xb5,0xd5,0x99,0x2e,0x70,0x41,0xa0,0x27,0x9e,0x1c,0x5e,0x98,0x95,0x41,0x7,0x51,0xe5,0xc4,0x6,0x12,0x0,0x4,0xf4,0xfb,0x2c,0x5,0x1,0x8,0xf,0x0,0xd7,0x76,0x9,0xb8,0xcd,0xe7,0x6e,0x41,0x92,0x38,0xc7,0xe,0x19,0x4d,0x94,0x41,0x50,0x98,0x5a,0xc4,0x0,0xc,0x0,0x0,0xf4,0xfb,0x30,0x5,0x1,0x8,0xf,0x0,0xa7,0xd5 };
				td.size = sizeof(buf);
				memcpy(td.data.buf, buf, td.size);		// < PKT_BUF_SIZE (2048)
				if (!generateDataAppend(testDeque, td, byteSize)) return;
			} break;

			case 2: {	// Ublox - UBX-NAV-POSLLH (0x01 0x02)
				td.ptype = _PTYPE_UBLOX;
				uint8_t buf[] = { 0xb5,0x62,0x1,0x2,0x1c,0x0,0x90,0xa2,0xad,0x10,0x6a,0xff,0x67,0xbd,0xb7,0xf4,0x9,0x18,0x35,0x7e,0x15,0x0,0xdf,0xc5,0x15,0x0,0x4f,0x1,0x0,0x0,0xa8,0x1,0x0,0x0,0xe1,0x2b };
				td.size = sizeof(buf);
				memcpy(td.data.buf, buf, td.size);		// < PKT_BUF_SIZE (2048)
				if (!generateDataAppend(testDeque, td, byteSize)) return;
			} break;

			case 3: {	// Ublox - UBX-RXM-RAWX (0x02 0x15)
				td.ptype = _PTYPE_UBLOX;
				uint8_t buf[] = { 0xb5,0x62,0x2,0x15,0xb0,0x3,0x81,0x95,0x43,0x8b,0x19,0x14,0x11,0x41,0x2b,0x8,0x12,0x1d,0x1,0x1,0xf2,0x7,0x6f,0x1f,0x77,0xfd,0xab,0xb,0x80,0x41,0xa0,0xcc,0x14,0x85,0x7d,0x14,0xa5,0x41,0x78,0x85,0x9c,0x43,0x1,0x85,0x0,0x0,0xf4,0xfb,0x2c,0x5,0x1,0x8,0xf,0x0,0x17,0xbd,0xc5,0x8d,0x69,0xc,0x83,0x41,0x12,0x42,0x8c,0xca,0x6d,0x6,0xa9,0x41,0x44,0xfc,0xc,0x44,0x5,0x2,0x0,0x0,0xf4,0xfb,0x25,0x6,0x1,0x8,0x7,0x0,0xae,0xc2,0xb4,0xd1,0x41,0x9f,0x70,0x41,0x2c,0xb7,0xc2,0x5e,0x62,0xd6,0x95,0x41,0x4e,0x22,0x31,0x45,0x0,0x5,0x0,0x0,0xf4,0xfb,0x30,0x5,0x1,0x8,0x7,0x0,0x94,0x60,0x66,0xa8,0xf7,0xa6,0x73,0x41,0x9d,0xff,0x92,0x27,0x7b,0xd1,0x99,0x41,0x8f,0xca,0x25,0xc5,0x0,0x13,0x0,0x0,0xf4,0xfb,0x27,0x5,0x1,0x8,0x7,0x0,0xb4,0xf1,0x8c,0xd3,0x52,0x11,0x70,0x41,0xc0,0x58,0x83,0x8c,0xea,0x1b,0x95,0x41,0x18,0xf,0xcf,0x44,0x0,0x19,0x0,0x0,0xf4,0xfb,0x2c,0x5,0x1,0x8,0x7,0x0,0x51,0x66,0xdb,0xb9,0xb7,0xc3,0x73,0x41,0x96,0x38,0x72,0x1e,0x3f,0xf7,0x99,0x41,0xb0,0x5c,0x95,0x44,0x2,0x1,0x0,0x0,0xf4,0xfb,0x2a,0x5,0x1,0x8,0x7,0x0,0x4c,0x65,0xc0,0x9a,0x77,0x33,0x6f,0x41,0xf0,0xbc,0x3d,0xa,0x92,0xd3,0x94,0x41,0x11,0x44,0x5d,0x44,0x6,0x9,0x0,0x5,0xf4,0xfb,0x26,0x5,0x1,0x8,0x7,0x0,0x0,0x9c,0xa6,0xcc,0x2,0x3f,0x6e,0x41,0x36,0x84,0x72,0x5f,0x7b,0x39,0x94,0x41,0x79,0x69,0x12,0x44,0x6,0x13,0x0,0xa,0xf4,0xfb,0x21,0x7,0x2,0x8,0x7,0x0,0xca,0x12,0x6,0xf2,0x5e,0x54,0x74,0x41,0x96,0x34,0xdd,0x9b,0x49,0xb5,0x9a,0x41,0x86,0x3e,0x11,0x45,0x2,0x8,0x0,0x0,0xf4,0xfb,0x27,0x5,0x1,0x8,0x7,0x0,0x47,0x7c,0x92,0xfa,0x20,0xd,0x72,0x41,0x92,0xd2,0x89,0x64,0xc,0xb7,0x97,0x41,0x6c,0x36,0xa5,0x44,0x2,0x1a,0x0,0x0,0xf4,0xfb,0x2a,0x5,0x1,0x8,0x7,0x0,0x8a,0x3e,0xbd,0x1e,0x6c,0xe1,0x70,0x41,0x3e,0x74,0x9b,0x14,0x3a,0x97,0x96,0x41,0x14,0x9,0xf5,0x44,0x6,0x3,0x0,0xc,0xf4,0xfb,0x2b,0x5,0x1,0x8,0x7,0x0,0x55,0xf2,0xb9,0xf5,0x50,0x5e,0x73,0x41,0x62,0x2b,0x75,0x8e,0x7,0x72,0x99,0x41,0x8c,0xe4,0xcb,0xc4,0x2,0x15,0x0,0x0,0xf4,0xfb,0x2a,0x5,0x1,0x8,0x7,0x0,0x6b,0x98,0xb0,0x68,0xc9,0x22,0x72,0x41,0x1b,0xd5,0xb,0x3b,0x7a,0x47,0x98,0x41,0xf6,0x33,0x86,0x45,0x6,0x4,0x0,0xd,0xf4,0xfb,0x26,0x6,0x1,0x8,0x7,0x0,0xc5,0x1c,0x77,0xf,0xe8,0x46,0x77,0x41,0xc2,0xde,0xec,0x5a,0x90,0x94,0x9e,0x41,0xc,0xbd,0x3f,0x45,0x2,0x1f,0x0,0x0,0xf4,0xfb,0x23,0x6,0x1,0x8,0x7,0x0,0xd9,0x27,0xc5,0xdc,0x51,0x5f,0x71,0x41,0x41,0x5b,0x7d,0xdf,0xc2,0x28,0x97,0x41,0xa7,0x6b,0x27,0x45,0x6,0xff,0x0,0x1,0x30,0x11,0x27,0x5,0x1,0x8,0xf,0x0,0xdc,0x19,0xbe,0xd0,0x6e,0x3d,0x76,0x41,0x2f,0x34,0xb3,0x4,0xcc,0x37,0x9d,0x41,0x44,0xca,0xfa,0xc4,0x2,0xf,0x0,0x0,0xf4,0xfb,0x25,0x5,0x1,0x8,0x7,0x0,0x86,0xdb,0xd6,0x4e,0xc2,0xe,0x72,0x41,0x6f,0x79,0x97,0x2b,0x31,0xb9,0x97,0x41,0xd,0xd4,0x35,0x45,0x0,0x1d,0x0,0x0,0xf4,0xfb,0x29,0x5,0x1,0x8,0x7,0x0,0x26,0xe9,0x53,0x9b,0xb3,0x37,0x72,0x41,0x6f,0xf4,0x7a,0xec,0xf9,0xee,0x97,0x41,0xa4,0x13,0x2a,0xc5,0x0,0x6,0x0,0x0,0xf4,0xfb,0x2a,0x5,0x1,0x8,0xf,0x0,0xe0,0x65,0xf9,0x72,0x8,0xdf,0x7f,0x41,0x94,0xd4,0xd0,0x99,0x7f,0xef,0xa4,0x41,0x78,0x1f,0x9b,0x43,0x1,0x8a,0x0,0x0,0xf4,0xfb,0x2b,0x5,0x1,0x8,0xf,0x0,0xd1,0x74,0x2f,0x92,0xc2,0xcd,0x72,0x41,0xe5,0xe7,0xd5,0x89,0x1e,0xb4,0x98,0x41,0xbc,0xdf,0x5e,0xc4,0x2,0xd,0x0,0x0,0xf4,0xfb,0x28,0x5,0x1,0x8,0x7,0x0,0xae,0x6f,0x55,0xc2,0xa4,0x3f,0x74,0x41,0xab,0x6,0x32,0x98,0xd,0x9a,0x9a,0x41,0x7a,0x3b,0x25,0xc5,0x0,0x18,0x0,0x0,0xf4,0xfb,0x24,0x6,0x1,0x8,0xf,0x0,0x3e,0xa4,0x61,0x85,0x9f,0x9f,0x70,0x41,0x3e,0xa4,0xf,0x7e,0x2f,0x33,0x96,0x41,0xca,0xe8,0x5a,0xc5,0x6,0x10,0x0,0x6,0xf4,0xfb,0x24,0x6,0x1,0x8,0xf,0x0,0xef,0x37,0x42,0x21,0xca,0x6f,0x70,0x41,0x9,0x31,0x4f,0x1b,0x5,0x98,0x95,0x41,0xea,0x10,0x91,0xc4,0x0,0x2,0x0,0x0,0xf4,0xfb,0x2c,0x5,0x1,0x8,0x7,0x0,0x61,0x6b,0xa5,0x4d,0x16,0x13,0x72,0x41,0x68,0x6d,0x8a,0xc9,0xc0,0x1c,0x98,0x41,0xda,0x67,0xae,0xc4,0x6,0x2,0x0,0x3,0xf4,0xfb,0x2a,0x5,0x1,0x8,0xf,0x0,0xe1,0x73,0x3e,0x87,0xeb,0x23,0x72,0x41,0x4e,0x95,0x47,0xe2,0x46,0x40,0x98,0x41,0x61,0x96,0x38,0x45,0x6,0x14,0x0,0x9,0xf4,0xfb,0x1e,0x8,0x3,0x8,0xf,0x0,0xcb,0xc8,0x82,0xb,0x70,0x56,0x76,0x41,0x7b,0x7b,0x3e,0xe1,0xa5,0x58,0x9d,0x41,0xbd,0x2f,0x35,0xc5,0x2,0x1b,0x0,0x0,0xf4,0xfb,0x24,0x5,0x1,0x8,0x7,0x0,0x7a,0x48,0xde,0xfa,0x97,0x19,0x74,0x41,0xd1,0x34,0xaf,0x8a,0x11,0x68,0x9a,0x41,0xf2,0x33,0xb7,0x44,0x0,0x1f,0x0,0x0,0xf4,0xfb,0x29,0x5,0x1,0x8,0xf,0x0,0xc3,0x4c,0xbf,0x3c,0x91,0x2e,0x70,0x41,0xf1,0x6c,0xab,0xa5,0x52,0x98,0x95,0x41,0x8c,0x45,0xe5,0xc4,0x6,0x12,0x0,0x4,0xf4,0xfb,0x2c,0x5,0x1,0x8,0xf,0x0,0x5e,0xee,0x27,0x65,0xc5,0xe7,0x6e,0x41,0xe8,0xc4,0xd,0x98,0x13,0x4d,0x94,0x41,0x33,0x7d,0x5a,0xc4,0x0,0xc,0x0,0x0,0xf4,0xfb,0x30,0x5,0x1,0x8,0xf,0x0,0x9c,0x9a };
				td.size = sizeof(buf);
				memcpy(td.data.buf, buf, td.size);		// < PKT_BUF_SIZE (2048)
				if (!generateDataAppend(testDeque, td, byteSize)) return;
			} break;
			}
		}
#endif

#if TEST_PROTO_RTCM3
		if (i % 50 == 0)
		{
			static int j = 0;
			switch (j++)
			{
			default: j = 0;	// fall-through
			case 0: {	// RTCM3 (0x19 0x3e)
				td.ptype = _PTYPE_RTCM3;
				uint8_t buf[] = { 0xd3,0x0,0x19,0x3e,0xfc,0x2f,0x14,0x41,0x44,0x56,0x4e,0x55,0x4c,0x4c,0x41,0x4e,0x54,0x45,0x4e,0x4e,0x41,0x20,0x20,0x4e,0x4f,0x4e,0x45,0x0,0xc4,0xe,0xe1 };
				td.size = sizeof(buf);
				memcpy(td.data.buf, buf, td.size);		// < PKT_BUF_SIZE (2048)
				if (!generateDataAppend(testDeque, td, byteSize)) return;
			} break;

			case 1: {	// RTCM3 (0x48 0x40)
				td.ptype = _PTYPE_RTCM3;
				uint8_t buf[] = { 0xd3,0x0,0x48,0x40,0x9c,0x2f,0x14,0x41,0x44,0x56,0x4e,0x55,0x4c,0x4c,0x41,0x4e,0x54,0x45,0x4e,0x4e,0x41,0x20,0x20,0x4e,0x4f,0x4e,0x45,0x0,0x0,0xd,0x54,0x52,0x49,0x4d,0x42,0x4c,0x45,0x20,0x4e,0x45,0x54,0x52,0x39,0x14,0x4e,0x61,0x76,0x20,0x34,0x2e,0x36,0x32,0x20,0x2f,0x20,0x42,0x6f,0x6f,0x74,0x20,0x34,0x2e,0x36,0x32,0xa,0x35,0x33,0x32,0x39,0x4b,0x34,0x34,0x33,0x35,0x32,0xfc,0xca,0x3f };
				td.size = sizeof(buf);
				memcpy(td.data.buf, buf, td.size);		// < PKT_BUF_SIZE (2048)
				if (!generateDataAppend(testDeque, td, byteSize)) return;
			} break;

			case 2: {	// RTCM3 (0x13 0x3e)
				td.ptype = _PTYPE_RTCM3;
				uint8_t buf[] = { 0xd3,0x0,0x13,0x3e,0xdc,0x2f,0x3,0x7b,0xcd,0x79,0xd5,0x47,0x35,0x77,0x5f,0x93,0x4d,0x49,0x8f,0xf1,0xb3,0x1d,0xff,0x10,0x3d };
				td.size = sizeof(buf);
				memcpy(td.data.buf, buf, td.size);		// < PKT_BUF_SIZE (2048)
				if (!generateDataAppend(testDeque, td, byteSize)) return;
			} break;

			case 3: {	// RTCM3 (0x3a 0x44)
				td.ptype = _PTYPE_RTCM3;
				uint8_t buf[] = { 0xd3,0x1,0x3a,0x44,0x7c,0x2f,0x52,0x3,0x6c,0x22,0x0,0x20,0x34,0x98,0x0,0xc0,0x0,0x0,0x0,0x0,0x4,0x0,0x88,0x80,0x7f,0xff,0xff,0xff,0xac,0x2a,0xad,0x29,0xa9,0xa7,0xa6,0xa7,0x80,0x0,0x0,0x0,0x6e,0x64,0x72,0xc7,0x4a,0xea,0x56,0xa3,0x32,0xfe,0xc0,0x1,0x0,0x4,0x0,0x10,0x0,0x40,0x1,0x0,0x4,0x0,0x10,0x0,0x3,0xf7,0x8,0x96,0x12,0x90,0x23,0xd7,0x25,0xbe,0x66,0xbc,0xd0,0x79,0xb9,0xc,0xbb,0x1b,0x5e,0x37,0x74,0x6d,0xe2,0x1d,0x94,0x45,0xc8,0xa2,0x51,0x5d,0xe3,0x3a,0xc6,0x81,0x8d,0xbb,0x19,0x8e,0x7b,0x5c,0xf3,0xd9,0xf1,0xf3,0xe0,0x6c,0x46,0xde,0x85,0xbd,0x4f,0x7c,0x1f,0x4,0x9e,0x16,0xfc,0x44,0xb8,0x81,0xff,0xff,0xf5,0xff,0xff,0x8f,0xff,0xeb,0xc0,0x0,0x15,0x7f,0xfe,0xe5,0xff,0xfa,0x28,0x0,0x11,0xdf,0xff,0xde,0x7f,0xfe,0xd8,0x0,0x1,0xcf,0xff,0xeb,0xdf,0xff,0xf1,0xff,0xff,0x8,0x0,0x6,0x10,0x0,0x6,0x3f,0xff,0x9c,0x80,0x0,0x47,0xff,0xfe,0xf0,0x0,0x14,0xff,0xff,0xa6,0x0,0x1,0x29,0xff,0xfc,0x58,0x0,0x9,0x0,0x0,0x56,0xff,0xff,0xe5,0xff,0xfb,0x50,0x0,0x12,0x3f,0xff,0xcc,0xff,0xff,0x2b,0xff,0xfb,0x17,0xff,0xfa,0x3f,0xff,0xf1,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x59,0x5e,0x15,0x61,0x6e,0xb7,0x55,0x66,0x35,0xd5,0x56,0x36,0xd9,0x5e,0x36,0x59,0x56,0x15,0xe3,0x7e,0xf8,0x65,0x87,0x19,0x40,0x0,0x80,0x1,0x0,0x2,0x0,0x4,0x0,0x8,0x0,0x10,0x0,0x20,0x0,0x40,0x0,0x80,0x1,0x0,0x2,0x0,0x4,0x0,0x8,0x0,0x10,0x0,0x20,0x0,0x40,0x0,0x80,0x1,0x0,0x2,0x0,0x4,0x0,0x8,0x0,0x10,0x0,0x20,0x0,0x40,0x0,0x80,0x1,0x0,0x2,0x0,0x4,0x0,0x8,0x0,0x10,0x0,0x20,0x0,0x0,0x1d,0x23,0x6c };
				td.size = sizeof(buf);
				memcpy(td.data.buf, buf, td.size);		// < PKT_BUF_SIZE (2048)
				if (!generateDataAppend(testDeque, td, byteSize)) return;
			} break;

			case 4: {	// RTCM3 (0xcc 0x43)
				td.ptype = _PTYPE_RTCM3;
				uint8_t buf[] = { 0xd3,0x0,0xcc,0x43,0xdc,0x2f,0x82,0x2f,0xc0,0xe2,0x0,0x20,0x4,0x3,0x41,0x0,0x0,0x0,0x0,0x0,0x30,0xc0,0x0,0x0,0x7f,0xff,0xfa,0x4a,0x1a,0x22,0x2a,0x54,0x3,0xdd,0x28,0xec,0x62,0x15,0xe,0xbb,0x90,0x0,0x40,0x1,0x0,0x4,0x0,0x10,0x0,0x75,0x28,0xea,0x45,0xd6,0x33,0xac,0x20,0x91,0x41,0x1d,0xa2,0x6b,0x84,0xcc,0xed,0x28,0xda,0xb,0xb5,0xc3,0x6b,0x87,0x2f,0x3e,0x57,0x1c,0xe3,0x79,0xd9,0x10,0xec,0x21,0xaa,0x47,0xa0,0x90,0xdf,0xff,0xfb,0x5f,0xff,0xee,0x7f,0xff,0xaf,0xff,0xfe,0xaf,0xff,0xfa,0xdf,0xff,0xea,0x0,0x1,0xa2,0x0,0x6,0x68,0x0,0xf,0x40,0x0,0x41,0x0,0x0,0x5c,0x0,0x1,0x68,0x0,0x14,0x9f,0xff,0xaf,0x0,0x1,0x2e,0x0,0x4,0xc0,0x0,0x13,0xe0,0x0,0x52,0x0,0x1,0x8a,0x0,0x6,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5f,0x75,0x96,0x67,0x96,0x38,0x65,0x8d,0xd7,0x5f,0x75,0x95,0xd9,0x64,0xd2,0xc0,0x0,0x80,0x1,0x0,0x2,0x0,0x4,0x0,0x8,0x0,0x10,0x0,0x20,0x0,0x40,0x0,0x80,0x1,0x0,0x2,0x0,0x4,0x0,0x8,0x0,0x10,0x0,0x20,0x0,0x40,0x0,0x80,0x1,0x0,0x2,0x0,0x0,0x9d,0xc4,0x6a };
				td.size = sizeof(buf);
				memcpy(td.data.buf, buf, td.size);		// < PKT_BUF_SIZE (2048)
				if (!generateDataAppend(testDeque, td, byteSize)) return;
			} break;
			}
		}
#endif

#if TEST_PROTO_SONY
		if (i % 50 == 0)
		{
			static int j = 0;
			switch (j++)
			{
			default: j = 0;	// fall-through
			case 0:	{
					td.ptype = _PTYPE_SONY;
					uint8_t buf[] = { 0x7F,0x0E,0x00,0x81,0x0E,0x80,0x61,0x7B,0x04,0xE0,0x17,0x59,0x3E,0x72,0xBD,0xA7,0x2F,0x02,0x00,0xF5 };
					td.size = sizeof(buf);
					memcpy(td.data.buf, buf, td.size);
					if (!generateDataAppend(testDeque, td, byteSize)) return;
				} break;

			case 1:	{
					td.ptype = _PTYPE_SONY;
					uint8_t buf[] = { 0x7F,0x1F,0x00,0x84,0x22,0x80,0x1C,0x00,0xD3,0x00,0x16,0x43,0xF0,0x00,0x88,0xEA,0xA7,0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x87,0xE2,0xB4,0x50 };
					td.size = sizeof(buf);
					memcpy(td.data.buf, buf, td.size);
					if (!generateDataAppend(testDeque, td, byteSize)) return;
				} break;

			case 2: {
					td.ptype = _PTYPE_SONY;
					uint8_t buf[] = { 0x7F,0x1F,0x00,0x84,0x22,0x80,0x1C,0x00,0xD3,0x00,0x16,0x43,0xF0,0x00,0x8A,0x21,0xD7,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0xC0,0x17,0xE9 };
					td.size = sizeof(buf);
					memcpy(td.data.buf, buf, td.size);
					if (!generateDataAppend(testDeque, td, byteSize)) return;
				} break;

			case 3: {
					td.ptype = _PTYPE_SONY;
					uint8_t buf[] = { 0x7F,0xAE,0x00,0x84,0xB1,0x80,0xAB,0x00,0xD3,0x00,0xA5,0x44,0x90,0x00,0x59,0xF5,0x82,0xB2,0x00,0x00,0x20,0x38,0x00,0xC0,0x08,0x00,0x00,0x00,0x20,0x00,0x00,0x80,0x5D,0x7E,0xAC,0xA0,0x94,0xAA,0xA6,0x9A,0xAA,0x00,0x00,0x00,0x1F,0xC8,0xD3,0xC8,0xA3,0x66,0x0D,0x5B,0x60,0x79,0xC3,0xFA,0xAF,0xC4,0x40,0x19,0xFF,0xDF,0xF1,0x5F,0x91,0x38,0xA6,0x88,0x51,0x3B,0x60,0x00,0x01,0xFC,0xE3,0xE7,0x64,0x27,0xD3,0x3F,0x20,0x00,0x00,0x27,0xA0,0x00,0x00,0x01,0xB4,0x69,0xA0,0x00,0x00,0x01,0xF5,0xF2,0x30,0x4C,0xDD,0xFF,0xFD,0xA6,0x1D,0xF2,0x80,0x0D,0x86,0xDE,0x12,0xAD,0x9C,0x00,0x00,0xB4,0x28,0xDE,0x7A,0x00,0x06,0xD1,0xDF,0xB0,0xAD,0xFF,0xFD,0x93,0x22,0x4C,0x60,0x04,0xC7,0x31,0xCC,0x60,0x04,0xC6,0x00,0x48,0x20,0x01,0x15,0xB1,0xB1,0x21,0xBE,0xB4,0xA2,0x6E,0x10,0x02,0xF0,0x00,0x2B,0x50,0x03,0x78,0xA8,0x6E,0x00,0x00,0x1E,0x27,0x47,0xEE,0x7F,0xA2,0x00,0x01,0xE5,0x49,0xF3,0x09,0x26,0x70,0x00,0x00,0x87,0x40,0x5C,0x5B };
					td.size = sizeof(buf);
					memcpy(td.data.buf, buf, td.size);
					if (!generateDataAppend(testDeque, td, byteSize)) return;
				} break;

			case 4: {
					td.ptype = _PTYPE_SONY;
					uint8_t buf[] = { 0x7F,0x1F,0x00,0x84,0x22,0x80,0x1C,0x00,0xD3,0x00,0x16,0x45,0xD0,0x00,0x59,0xF5,0x82,0xB2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x48,0xD5,0xA9 };
					td.size = sizeof(buf);
					memcpy(td.data.buf, buf, td.size);
					if (!generateDataAppend(testDeque, td, byteSize)) return;
				} break;

			case 5: {
					td.ptype = _PTYPE_SONY;
					// uint8_t buf[] = { 0x7F,0x1F,0x00,0x84,0x22,0x80,0x1C,0x00,0xD3,0x00,0x16,0x46,0x70,0x00,0x59,0xF4,0xA7,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4A,0x14,0x8F,0x0C };
					uint8_t buf[] = { 0x7F,0x0E,0x00,0x81,0x0E,0x80,0x61,0x52,0x04,0xE0,0x17,0x34,0x3E,0x72,0xBD,0xD9,0x2F,0x02,0x00,0xD9 };
					td.size = sizeof(buf);
					memcpy(td.data.buf, buf, td.size);
					if (!generateDataAppend(testDeque, td, byteSize)) return;
				} break;
			}
		}
#endif
	}
}


void addDequeToRingBuf(std::deque<data_holder_t> &testDeque, ring_buf_t *rbuf)
{
	is_comm_instance_t		comm;
	uint8_t					comm_buffer[2048] = { 0 };
	is_comm_init(&comm, comm_buffer, sizeof(comm_buffer));

	int k=0;

	for (int i = 0; i < testDeque.size(); i++)
	{
		data_holder_t &td = testDeque[i];
		int n = 0;

		// Add packetized data to ring buffer
		switch (td.ptype)
		{
		case _PTYPE_INERTIAL_SENSE_DATA:
			// Packetize data 
			uint8_t buf[COM_BUFFER_SIZE];
			n = is_comm_set_data_to_buf(buf, sizeof(buf), &comm, td.did, td.size, 0, (void*)&(td.data));
			td.pktSize = n;
			EXPECT_FALSE(ringBufWrite(rbuf, buf, n));
			break;

		case _PTYPE_NMEA:
		case _PTYPE_UBLOX:
		case _PTYPE_RTCM3:
		case _PTYPE_SONY:
			td.pktSize = td.size;
			EXPECT_FALSE(ringBufWrite(rbuf, td.data.buf, td.size));
			break;
		}
	}

	// Buffer overflow not allowed for test
	ASSERT_TRUE(ringBufFree(rbuf));
}


void parseRingBufByte(std::deque<data_holder_t> &testDeque, ring_buf_t &ringBuf)
{
	is_comm_instance_t &comm = g_comm;
	unsigned char c;
	protocol_type_t ptype;
	uDatasets dataWritten;
	int found=0;

	while (ringBufUsed(&ringBuf)>0 && testDeque.size()>0)
	{
		ringBufRead(&ringBuf, &c, 1);
		EXPECT_GT(is_comm_free(&comm), 0);

		if((ptype = is_comm_parse_byte(&comm, c)) != _PTYPE_NONE)
		{
			found++;
			EXPECT_NE(ptype, _PTYPE_PARSE_ERROR);

			data_holder_t td = testDeque.front();
			testDeque.pop_front();

			switch (ptype)
			{
			case _PTYPE_INERTIAL_SENSE_DATA:
				DEBUG_PRINTF("[%d] Found data: did %3d, size %3d\n", found, comm.rxPkt.hdr.id, comm.rxPkt.data.size);

				is_comm_copy_to_struct(&dataWritten, &comm, sizeof(uDatasets));

				EXPECT_EQ((int)td.did, (int)comm.rxPkt.hdr.id);
				break;

			case _PTYPE_UBLOX:	DEBUG_PRINTF("[%d] Found data: UBLOX size %d, (0x%02x 0x%02x)\n", found, comm.rxPkt.data.size, comm.rxPkt.data.ptr[2], comm.rxPkt.data.ptr[3]);		break;
			case _PTYPE_RTCM3:	DEBUG_PRINTF("[%d] Found data: RTCM3 size %d, (%02x %02x %02x %02x)\n", found, comm.rxPkt.data.size, comm.rxPkt.data.ptr[0], comm.rxPkt.data.ptr[1], comm.rxPkt.data.ptr[2], comm.rxPkt.data.ptr[3]);	break;
			case _PTYPE_SONY:	DEBUG_PRINTF("[%d] Found data: SONY size %d, (OPC 0x%02x)\n", found, comm.rxPkt.data.size, comm.rxPkt.data.ptr[3]);		break;

			case _PTYPE_NMEA:
				DEBUG_PRINTF("[%d] ", found);
				printNmeaMessage("Found data", comm.rxPkt.data.ptr, comm.rxPkt.data.size);
				break;
			}

			EXPECT_EQ(td.size, comm.rxPkt.data.size);
			EXPECT_TRUE(memcmp(td.data.buf, comm.rxPkt.data.ptr, td.size) == 0);
		}
		else
		{
			if (ringBufUsed(&ringBuf) == 0)
			{
				return;
			}
		}		
	}
}

void parseRingBufMultiByte(std::deque<data_holder_t> &testDeque, ring_buf_t &ringBuf)
{
	is_comm_instance_t &comm = g_comm;
	protocol_type_t ptype;
	uDatasets dataWritten;
	int found=0;

	while (ringBufUsed(&ringBuf)>0 && testDeque.size()>0)
	{
		int n = _MIN(ringBufUsed(&ringBuf), is_comm_free(&comm));
		EXPECT_GT(n, 0);

		ringBufRead(&ringBuf, comm.rxBuf.tail, n);

        // Update comm buffer tail pointer
        comm.rxBuf.tail += n;

        while ((ptype = is_comm_parse(&comm)) != _PTYPE_NONE) 
		{
			found++;
			data_holder_t td = testDeque.front();
			testDeque.pop_front();

			EXPECT_NE(ptype, _PTYPE_PARSE_ERROR);

			switch (ptype)
			{
			case _PTYPE_INERTIAL_SENSE_DATA:
				// Found data
				DEBUG_PRINTF("[%d] Found data: did %3d, size %3d\n", found, comm.rxPkt.hdr.id, comm.rxPkt.data.size);

				is_comm_copy_to_struct(&dataWritten, &comm, sizeof(uDatasets));

				EXPECT_EQ((int)td.did, (int)comm.rxPkt.hdr.id);
				break;

			case _PTYPE_UBLOX:	DEBUG_PRINTF("[%d] Found data: Ublox size %3d\n", found, comm.rxPkt.data.size);		break;
			case _PTYPE_RTCM3:	DEBUG_PRINTF("[%d] Found data: RTCM3 size %3d\n", found, comm.rxPkt.data.size);		break;
			case _PTYPE_SONY: 	DEBUG_PRINTF("[%d] Found data: Sony size %3d\n", found, comm.rxPkt.data.size);		break;

			case _PTYPE_NMEA:
				DEBUG_PRINTF("[%d] ", found);
				printNmeaMessage("Found data", comm.rxPkt.data.ptr, comm.rxPkt.data.size);
				break;
			}

			EXPECT_EQ(td.size, comm.rxPkt.data.size);
			EXPECT_TRUE(memcmp(td.data.buf, comm.rxPkt.data.ptr, td.size) == 0);
		}
	}
}


static void ringBuftoRingBufWrite(ring_buf_t *dst, ring_buf_t *src, int len)
{
	uint8_t *buf = new uint8_t[len];

	len = ringBufRead(src, buf, len);
	EXPECT_FALSE(ringBufWrite(dst, buf, len));
}

static int generate_ISBPkt_DevInfo(is_comm_instance_t* comm, uint8_t* buf, int buffSize)
{
	dev_info_t dev;

	// Dev Info
	dev.hardwareType = 4;
	dev.serialNumber = 234532;
	dev.hardwareVer[0] = 1;
	dev.hardwareVer[1] = 0;
	dev.hardwareVer[2] = 0;
	dev.hardwareVer[3] = 0;
	dev.firmwareVer[1] = 2;
	dev.firmwareVer[2] = 4;
	dev.firmwareVer[3] = 2;
	dev.firmwareVer[4] = 125;
	dev.buildNumber = 4532345;
	dev.protocolVer[0] = 2;
	dev.protocolVer[1] = 0;
	dev.protocolVer[2] = 0;
	dev.protocolVer[3] = 0;
	dev.repoRevision = 0x65682a70;
	dev.buildType = 'c';
	dev.buildYear = 25;
	dev.buildMonth = 5;
	dev.buildDay = 13;
	dev.buildHour = 14;
	dev.buildMinute = 19;
	dev.buildSecond = 55;
	dev.buildMillisecond = 134;

	strncpy(dev.manufacturer, "Inertial Sense Inc", DEVINFO_MANUFACTURER_STRLEN);
	strncpy(dev.addInfo, "GPX-1", DEVINFO_ADDINFO_STRLEN);

	return is_comm_write_to_buf(buf, buffSize, comm, PKT_TYPE_DATA, DID_DEV_INFO, sizeof(dev_info_t), 0, &dev);;
}

static int generate_NMEAPkt_DevInfo(is_comm_instance_t* comm, uint8_t* buf, int buffSize)
{
	dev_info_t dev;

	// Dev Info
	dev.hardwareType = 4;
	dev.serialNumber = 234532;
	dev.hardwareVer[0] = 1;
	dev.hardwareVer[1] = 0;
	dev.hardwareVer[2] = 0;
	dev.hardwareVer[3] = 0;
	dev.firmwareVer[1] = 2;
	dev.firmwareVer[2] = 4;
	dev.firmwareVer[3] = 2;
	dev.firmwareVer[4] = 125;
	dev.buildNumber = 4532345;
	dev.protocolVer[0] = 2;
	dev.protocolVer[1] = 0;
	dev.protocolVer[2] = 0;
	dev.protocolVer[3] = 0;
	dev.repoRevision = 0x65682a70;
	dev.buildType = 'c';
	dev.buildYear = 25;
	dev.buildMonth = 5;
	dev.buildDay = 13;
	dev.buildHour = 14;
	dev.buildMinute = 19;
	dev.buildSecond = 55;
	dev.buildMillisecond = 134;

	strncpy(dev.manufacturer, "Inertial Sense Inc", DEVINFO_MANUFACTURER_STRLEN);
	strncpy(dev.addInfo, "GPX-1", DEVINFO_ADDINFO_STRLEN);


	return nmea_dev_info((char*)buf, buffSize, dev);
}

static int generate_ISBPkt_gps1Pos(is_comm_instance_t* comm, uint8_t* buf, int buffSize)
{
	gps_pos_t gps;

	// GPS
	gps.week = 2270;
	gps.timeOfWeekMs = 12345678;
	gps.status = 0x03457834;
	gps.ecef[0] = 2345.967;
	gps.ecef[1] = 134.0687;
	gps.ecef[2] = -8657.2345;
	gps.lla[0] = 40.330565516;
	gps.lla[1] = -111.725787806;
	gps.lla[2] = 1408.565264;
	gps.hMSL = 1408.565264;
	gps.hAcc = 0.16546;
	gps.vAcc = 2.3423;
	gps.pDop = 1.053;
	gps.cnoMean = 38.928;
	gps.towOffset = 7254.0982;
	gps.leapS = 18;
	gps.satsUsed = 25;
	gps.cnoMeanSigma = 2;
	gps.status2 = 0x05;

	return is_comm_write_to_buf(buf, buffSize, comm, PKT_TYPE_DATA, DID_GPS1_POS, sizeof(gps_pos_t), 0, &gps);
}

static int generate_ISBPkt_ins2(is_comm_instance_t* comm, uint8_t* buf, int buffSize)
{
	ins_2_t ins;

	// INS2
	ins.week = 2270;
	ins.timeOfWeek = 12345678;
	ins.insStatus = 0x12345678;
	ins.hdwStatus = 0x87654321;
	ins.qn2b[0] = 173.895;
	ins.qn2b[1] = 762.54;
	ins.qn2b[2] = 93.267;
	ins.qn2b[3] = 5.45;
	ins.uvw[0] = 2.23;
	ins.uvw[1] = 789.543;
	ins.uvw[2] = 123.546;
	ins.lla[0] = 40.330565516;
	ins.lla[1] = -111.725787806;
	ins.lla[2] = 1408.565264;

	return is_comm_write_to_buf(buf, buffSize, comm, PKT_TYPE_DATA, DID_INS_2, sizeof(ins_2_t), 0, &ins);
}

static int generate_ISBPkt_imu(is_comm_instance_t* comm, uint8_t* buf, int buffSize)
{
	imu_t imu;

	// IMU
	imu.time = 25670.98;
	imu.status = 0x9876543;
	imu.I.pqr[0] = 1234.;
	imu.I.pqr[1] = 5643.;
	imu.I.pqr[2] = -93.5678;
	imu.I.acc[0] = -321.567;
	imu.I.acc[1] = 2134.456;
	imu.I.acc[2] = 4123.856;

	return is_comm_write_to_buf(buf, buffSize, comm, PKT_TYPE_DATA, DID_IMU, sizeof(imu_t), 0, &imu);
}

#if BASIC_TX_BUFFER_RX_BYTE_TEST
TEST(ISComm, BasicTxBufferRxByteTest)
{
	// Initialize Com Manager
	init(tcm);

	// Generate and add data to deque
	generateData(g_testTxDeque);

	// Use Com Manager to send deque data to Tx port ring buffer
	for(int i=0; i<g_testTxDeque.size(); i++)
	{
		data_holder_t td = g_testTxDeque[i];

		// Send data - writes data to tcm.txBuf
		int n;
		switch (td.ptype)
		{
		default:	// IS binary
			uint8_t buf[COM_BUFFER_SIZE];
			n = is_comm_data_to_buf(buf, sizeof(buf), &g_comm, td.did, td.size, 0, td.data.buf);
			portWrite(0, buf, n);
			break;

		case _PTYPE_NMEA:
		case _PTYPE_UBLOX:
		case _PTYPE_RTCM3:
		case _PTYPE_SONY:
			portWrite(0, td.data.buf, td.size);
			break;
		}
	}

	// Test that data parsed from Tx port matches deque data
	parseRingBufByte(g_testTxDeque, tcm.portTxBuf);

	// Check that we got all data
	EXPECT_TRUE(g_testTxDeque.empty());
	EXPECT_TRUE(ringBufUsed(&tcm.portTxBuf) == 0);
	EXPECT_EQ(g_comm.rxErrorCount, 0);
}
#endif


#if BASIC_TX_PORT_RX_BYTE_TEST
TEST(ISComm, BasicTxPortRxByteTest)
{
	// Initialize Com Manager
	init(tcm);

	// Generate and add data to deque
	generateData(g_testTxDeque);

	// Use Com Manager to send deque data to Tx port ring buffer
	for(int i=0; i<g_testTxDeque.size(); i++)
	{
		data_holder_t td = g_testTxDeque[i];

		// Send data - writes data to tcm.txBuf
		int n;
		switch (td.ptype)
		{
		default:	// IS binary
			n = is_comm_data(portWrite, 0, &g_comm, td.did, td.size, 0, td.data.buf);
			break;

		case _PTYPE_NMEA:
		case _PTYPE_UBLOX:
		case _PTYPE_RTCM3:
		case _PTYPE_SONY:
			portWrite(0, td.data.buf, td.size);
			break;
		}
	}

	// Test that data parsed from Tx port matches deque data
	parseRingBufByte(g_testTxDeque, tcm.portTxBuf);

	// Check that we got all data
	EXPECT_TRUE(g_testTxDeque.empty());
	EXPECT_TRUE(ringBufUsed(&tcm.portTxBuf) == 0);
	EXPECT_EQ(g_comm.rxErrorCount, 0);
}
#endif


#if BASIC_TX_RX_MULTI_BYTE_TEST
TEST(ISComm, BasicTxRxMultiByteTest)
{
	// Initialize Com Manager
	init(tcm);

	// Generate and add data to deque
	generateData(g_testTxDeque);

	// Use Com Manager to send deque data to Tx port ring buffer
	for(int i=0; i<g_testTxDeque.size(); i++)
	{
		data_holder_t td = g_testTxDeque[i];

		// Send data - writes data to tcm.txBuf
		int n;
		switch (td.ptype)
		{
		case _PTYPE_INERTIAL_SENSE_DATA:	// IS binary
		case _PTYPE_INERTIAL_SENSE_CMD:
			n = is_comm_data(portWrite, 0, &g_comm, td.did, td.size, 0, td.data.buf);
			break;

		case _PTYPE_NMEA:
		case _PTYPE_UBLOX:
		case _PTYPE_RTCM3:
		case _PTYPE_SONY:
			portWrite(0, td.data.buf, td.size);
			break;
		}
	}

	// Test that data parsed from Tx port matches deque data
	parseRingBufMultiByte(g_testTxDeque, tcm.portTxBuf);

	// Check that we got all data
	EXPECT_TRUE(g_testTxDeque.empty());
	EXPECT_TRUE(ringBufUsed(&tcm.portTxBuf) == 0);
	EXPECT_EQ(g_comm.rxErrorCount, 0);
}
#endif


#if TXRX_MULTI_BYTE_PRECEEDED_BY_GARBAGE
TEST(ISComm, TxRxMultiBytePreceededByGarbage)
{
	// Initialize Com Manager
	init(tcm);
	g_comm.rxErrorState = 0;	// is_comm_init() sets this to -1 to prevent initial stray data from registering as a parse error.

	// Generate and add data to deque
	generateData(g_testTxDeque);

	protocol_type_t ptype;
	int rxErrorCount = 0;

	for (int i=0; i<3; i++)
	{
		// Add garbage data that starts with ISB preamble
		*g_comm.rxBuf.tail = 13; g_comm.rxBuf.tail++;

		// Parse garbage data
		ptype = is_comm_parse(&g_comm);
		EXPECT_EQ(ptype, _PTYPE_PARSE_ERROR);
		rxErrorCount++;
		EXPECT_EQ(rxErrorCount, g_comm.rxErrorCount);

		// Add garbage data that starts with ISB preamble
		*g_comm.rxBuf.tail = PSC_ISB_PREAMBLE_BYTE1; g_comm.rxBuf.tail++;
		*g_comm.rxBuf.tail = PSC_ISB_PREAMBLE_BYTE2; g_comm.rxBuf.tail++;
	#define GARBAGE_STR	"Garbage string.  Hello!\n"
		memcpy(g_comm.rxBuf.tail, GARBAGE_STR, sizeof(GARBAGE_STR)); g_comm.rxBuf.tail += sizeof(GARBAGE_STR);

		// Read start of correctup ISB packet
		ptype = is_comm_parse(&g_comm);
		EXPECT_EQ(ptype, _PTYPE_NONE);
		EXPECT_EQ(rxErrorCount, g_comm.rxErrorCount);

		// Add good packet to buffer
		data_holder_t td = g_testTxDeque[0];
		int n = is_comm_data_to_buf(g_comm.rxBuf.tail, (uint32_t)(g_comm.rxBuf.end - g_comm.rxBuf.head), &g_comm, td.did, td.size, 0, td.data.buf);
		g_comm.rxBuf.tail += n;

		// Parse data to find good packet
		ptype = is_comm_parse(&g_comm);
		EXPECT_EQ(ptype, _PTYPE_INERTIAL_SENSE_DATA);

		EXPECT_EQ(g_comm.rxPkt.data.size, td.size);
		EXPECT_TRUE(memcmp(g_comm.rxPkt.data.ptr, td.data.buf, td.size) == 0);
		EXPECT_EQ(rxErrorCount, g_comm.rxErrorCount);
	}
}
#endif


#if TXRX_WITH_OFFSET_TEST
TEST(ISComm, TxRxWithOffsetTest)
{
	// Initialize Com Manager
	init(tcm);

	ins_1_t txIns1 = {};
	txIns1.timeOfWeek = 1.234;
	txIns1.theta[2] = 2.345f;
	int n;

	n = is_comm_data(portWrite, 0, &g_comm, DID_INS_1, sizeof(double), offsetof(ins_1_t,timeOfWeek), &txIns1.timeOfWeek);
	n = is_comm_data(portWrite, 0, &g_comm, DID_INS_1, sizeof(float), offsetof(ins_1_t,theta[2]), &txIns1.theta[2]);

	{
		is_comm_init(&g_comm, g_comm_buffer, COM_BUFFER_SIZE);
		ins_1_t rxIns1 = {};

		int n = ringBufUsed(&tcm.portTxBuf);
		ringBufRead(&tcm.portTxBuf, g_comm.rxBuf.tail, n);
		g_comm.rxBuf.tail += n;

		// Read timeOfWeek
        EXPECT_EQ( is_comm_parse(&g_comm), _PTYPE_INERTIAL_SENSE_DATA);
		DEBUG_PRINTF("Found data: did %3d, size %3d\n", g_comm.rxPkt.hdr.id, g_comm.rxPkt.data.size);
		is_comm_copy_to_struct(&rxIns1, &g_comm, sizeof(uDatasets));
		// Read theta[2]
        EXPECT_EQ( is_comm_parse(&g_comm), _PTYPE_INERTIAL_SENSE_DATA);
		DEBUG_PRINTF("Found data: did %3d, size %3d\n", g_comm.rxPkt.hdr.id, g_comm.rxPkt.data.size);
		is_comm_copy_to_struct(&rxIns1, &g_comm, sizeof(uDatasets));

		EXPECT_TRUE( memcmp(&txIns1, &rxIns1, sizeof(rxIns1)) == 0 );
		EXPECT_EQ(g_comm.rxErrorCount, 0);
	}
}
#endif


#if SEGMENTED_RX_TEST
// Tests ISComm handles segmented serial data properly
TEST(ISComm, SegmentedRxTest)
{
	ring_buf_t tmpRBuf;
	uint8_t buffer[PORT_BUFFER_SIZE];

	// Initialize temporary ring buffer
	ringBufInit(&tmpRBuf, buffer, sizeof(buffer), 1);

	init(tcm);

	// Generate and add data to deque
	generateData(g_testRxDeque);

	// Add deque data to temporary ring buffer
	addDequeToRingBuf(g_testRxDeque, &tmpRBuf);

	DEBUG_PRINTF("Checking Data:\n");

	// Divide data written to Com Manager into pieces
#define TIMES_TO_DIVIDE_DATA 10
	int bytesToWrite = ringBufUsed(&tmpRBuf) / TIMES_TO_DIVIDE_DATA;
	while (!ringBufEmpty(&tmpRBuf) && !g_testRxDeque.empty())
	{
		// Partial write of data
		ringBuftoRingBufWrite(&tcm.portRxBuf, &tmpRBuf, bytesToWrite);

		while (!ringBufEmpty(&tcm.portRxBuf))
		{
			// Test that data parsed from Rx port matches deque data
			parseRingBufByte(g_testRxDeque, tcm.portRxBuf);
		}
	}

	// Check that no data was left behind 
	EXPECT_TRUE(g_testRxDeque.empty());
	EXPECT_TRUE(ringBufEmpty(&tcm.portRxBuf));
	EXPECT_EQ(g_comm.rxErrorCount, 0);
}
#endif


#if BLAST_RX_TEST
// Tests that ComManager handles segmented serial data properly
TEST(ISComm, BlastRxTest)
{
	ring_buf_t tmpRBuf;
	uint8_t buffer[PORT_BUFFER_SIZE];

	// Initialize temporary ring buffer
	ringBufInit(&tmpRBuf, buffer, sizeof(buffer), 1);

	init(tcm);

	// Generate and add data to deque
	generateData(g_testRxDeque);

	// Add deque data to temporary ring buffer
	addDequeToRingBuf(g_testRxDeque, &tmpRBuf);

	DEBUG_PRINTF("Checking Data:\n");

	// Divide data written to Com Manager into pieces
	int bytesToWrite = ringBufFree(&tcm.portRxBuf);
	while (!ringBufEmpty(&tmpRBuf) && !g_testRxDeque.empty())
	{
		// Partial write of data
		ringBuftoRingBufWrite(&tcm.portRxBuf, &tmpRBuf, bytesToWrite);

		while (!ringBufEmpty(&tcm.portRxBuf))
		{
			// Test that data parsed from Rx port matches deque data
			parseRingBufByte(g_testRxDeque, tcm.portRxBuf);
		}
	}

	// Check that no data was left behind 
	EXPECT_TRUE(g_testRxDeque.empty());
	EXPECT_TRUE(ringBufEmpty(&tcm.portRxBuf));
	EXPECT_EQ(g_comm.rxErrorCount, 0);
}
#endif


#if 0
TEST(ISComm, RxWithGarbageTest)
{
	// Initialize Com Manager
	init(tcm);

	// Generate and add data to deque
	generateData(g_testRxDeque);

	// Insert garbage
	std::deque<data_holder_t> testRxDequeWithGarbage;
	data_holder_t td = {};
	td.size = 24;
	td.data.buf[1] = 128;
	td.data.buf[19] = 128;
	td.data.buf[23] = 128;

	for (int i = 0; i < g_testRxDeque.size(); i++)
	{
		if (i % 5 == 0)
		{
			// Insert garbage data
			testRxDequeWithGarbage.push_back(td);
		}

		// Copy good data
		testRxDequeWithGarbage.push_back(g_testRxDeque[i]);
	}

	// Add deque data to Rx port ring buffer
	addDequeToRingBuf(testRxDequeWithGarbage, &tcm.portRxBuf);

	DEBUG_PRINTF("===============  Checking Data.  Size: %d  ===============\n", ringBufUsed(&tcm.portRxBuf));

	while (!ringBufEmpty(&tcm.portRxBuf))
	{
		// Test that data parsed from Rx port matches deque data
		parseRingBufByte(g_testRxDeque, tcm.portRxBuf);
	}

	// Check that no data was left behind 
	EXPECT_TRUE(g_testRxDeque.empty());
	EXPECT_TRUE(ringBufUsed(&tcm.portRxBuf) == 0);
}
#endif


#if 0
TEST(ISComm, IsCommGetDataTest)
{
	// Initialize Com Manager
	init(tcm);

	int did = DID_INS_2;
	int size = sizeof(double)*3;
	int offset = offsetof(ins_2_t, lla);
	int period = 3;

	// Generate packet
	int n = is_comm_get_data(portWrite, 0, &g_comm, did, size, offset, period);

	// Reset buffer if needed
	is_comm_free(&g_comm);
	
	// Add byte to buffer
	ringBufRead(&tcm.portTxBuf, g_comm.rxBuf.tail, size);
	g_comm.rxBuf.tail += size;

	// Parse packet
	protocol_type_t ptype = is_comm_parse(&g_comm);

	EXPECT_TRUE(ptype == _PTYPE_INERTIAL_SENSE_CMD);

	p_data_get_t *request = (p_data_get_t*)g_comm.rxPkt.data.ptr;
	EXPECT_EQ(request->id,     did);
	EXPECT_EQ(request->size,   size);
	EXPECT_EQ(request->offset, offset);
	EXPECT_EQ(request->period, period);
}
#endif


#if TEST_ALTERNATING_ISB_NMEA_PARSE_ERRORS
uint8_t rxBuf[8192] = {0};
uint8_t txBuf[1024] = {0};		// This buffer is intentially left smaller for testing

#define BUF_FREE    (uint32_t)(txEnd-txPtr)
#define BUF_USED    (uint32_t)(txPtr-txBuf)
#define WHILE_FULL  if (txPtr > txEnd - 100) break;

TEST(ISComm, alternating_isb_nmea_parse_error_check)
{
    int n;

    is_comm_init(&g_comm, rxBuf, sizeof(rxBuf));

    uint8_t *txPtr = txBuf;
    uint8_t *txEnd = txBuf + sizeof(txBuf);

    int msgCntIsb = 0;
    int msgCntNmea = 0;

    for (int i=0;; i++)
    {
        // append NMEA dev info
        dev_info_t info = {};
        info.serialNumber = 123456 + i;
        info.buildNumber = 789 + i;
        n = nmea_dev_info((char*)txPtr, BUF_FREE, info);
        txPtr += n;
        msgCntNmea++;
        WHILE_FULL;

        // append ISB get data DEV_INFO
        n = is_comm_get_data_to_buf(txPtr, BUF_FREE, &g_comm, DID_DEV_INFO, sizeof(dev_info_t), 0, 0);
        txPtr += n;
        msgCntIsb++;
        WHILE_FULL;

        // append NMEA query dev info
        memcpy(txPtr, NMEA_CMD_QUERY_DEVICE_INFO, n = NMEA_CMD_SIZE);
        txPtr += n;
        msgCntNmea++;
        WHILE_FULL;

        // append ISB DID_INS_1
        ins_1_t ins1 = {};
        ins1.timeOfWeek = 123.456 + i*2;
        ins1.hdwStatus = 78 + i*2;
        ins1.insStatus = 90 + i*2;
        n = is_comm_data_to_buf(txPtr, BUF_FREE, &g_comm, DID_INS_1, sizeof(ins_1_t), 0, &ins1);
        txPtr += n;
        msgCntIsb++;
        WHILE_FULL;
    }


    for (txPtr = txBuf; txPtr < txEnd; )
    {
		// Get available size of g_comm buffer.
		n = _MIN(is_comm_free(&g_comm), 10);

		// Read data directly into g_comm buffer
        memcpy(g_comm.rxBuf.tail, txPtr, n);

        // Update g_comm buffer tail pointer
        txPtr += n;
        g_comm.rxBuf.tail += n;

        // Search g_comm buffer for valid packets
        protocol_type_t ptype;
        while ((ptype = is_comm_parse(&g_comm)) != _PTYPE_NONE)
        {
            ASSERT_EQ(g_comm.rxErrorCount, 0);

            uint8_t error = 0;
            uint8_t *dataPtr = g_comm.rxPkt.data.ptr + g_comm.rxPkt.dataHdr.offset;
            uint32_t dataSize = g_comm.rxPkt.data.size;

            switch (ptype)
            {
            case _PTYPE_PARSE_ERROR:
                error = 1;
                break;

            case _PTYPE_INERTIAL_SENSE_DATA:
            case _PTYPE_INERTIAL_SENSE_CMD:
                msgCntIsb--;
                if (!msgCntIsb && !msgCntNmea) { ASSERT_TRUE(true); return; } // Done
                break;

            case _PTYPE_NMEA:
                msgCntNmea--;
                if (!msgCntIsb && !msgCntNmea) { ASSERT_TRUE(true); return; } // Done
                break;

            default:    // We shouldn't get here
                ASSERT_TRUE(false);
            }
        }
    }

    ASSERT_EQ(g_comm.rxErrorCount, 0);
    ASSERT_EQ(msgCntIsb, 0);
    ASSERT_EQ(msgCntNmea, 0);
}
#endif


#if TEST_TRUNCATED_PACKETS
TEST(ISComm, TruncatedPackets)
{
	// Initialize Com Manager
	init(tcm);
	g_comm.rxErrorState = 0;	// is_comm_init() sets this to -1 to prevent initial stray data from registering as a parse error.

	// Generate and add data to deque
	generateData(g_testTxDeque);

	int badPktCount = 0, goodPktCount = 0;
	uint8_t buf[COM_BUFFER_SIZE] = {0};

	// Use Com Manager to send deque data to Tx port ring buffer
	for(int i=0; i<g_testTxDeque.size(); i++)
	{
		data_holder_t td = g_testTxDeque[i];

		// Send data - writes data to tcm.txBuf
		int n;
		switch (td.ptype)
		{
		case _PTYPE_INERTIAL_SENSE_DATA:	// IS binary
		case _PTYPE_INERTIAL_SENSE_CMD:
			n = is_comm_data_to_buf(buf, sizeof(buf), &g_comm, td.did, td.size, 0, td.data.buf);
			if (i%4 == 0)
			{	// Throw away half of packet
				n = n/2;
				badPktCount++;
				DEBUG_PRINTF("[%d] (%d) Bad  %d\n", i, n, badPktCount);
			}
			else
			{
				goodPktCount++;
				DEBUG_PRINTF("[%d] (%d) Good %d\n", i, n, goodPktCount);
			}
			portWrite(0, buf, n);
			break;

		case _PTYPE_NMEA:
		case _PTYPE_UBLOX:
		case _PTYPE_RTCM3:
		case _PTYPE_SONY:
			n = td.size;
			if (i%4 == 0)
			{	// Throw away half of packet
				n = n/2;
				badPktCount++;
				DEBUG_PRINTF("[%d] (%d) Bad  %d\n", i, n, badPktCount);
			}
			else
			{
				goodPktCount++;
				DEBUG_PRINTF("[%d] (%d) Good %d\n", i, n, goodPktCount);
			}
			portWrite(0, td.data.buf, n);
			break;
		}
	}

	// Test that data parsed from Tx port matches deque data
	is_comm_instance_t &comm = g_comm;
	protocol_type_t ptype;
	uDatasets dataWritten;
	int found=0;

	while (g_testTxDeque.size()>0)
	{
		int n = _MIN(ringBufUsed(&tcm.portTxBuf), is_comm_free(&comm));
		ringBufRead(&tcm.portTxBuf, comm.rxBuf.tail, n);

        // Update comm buffer tail pointer
        comm.rxBuf.tail += n;

		bool priorBad = false;
        while ((ptype = is_comm_parse(&comm)) != _PTYPE_NONE) 
		{
			if (ptype == _PTYPE_PARSE_ERROR && priorBad)
			{	// Ignore sequential parse errors
				continue;
			}

			data_holder_t td = g_testTxDeque.front();
			g_testTxDeque.pop_front();

			switch (ptype)
			{
			case _PTYPE_INERTIAL_SENSE_DATA:
				// Found data
				DEBUG_PRINTF("[%d] (%d) Good %d: ISB %3d\n", found, comm.rxPkt.data.size, g_comm.rxPktCount, comm.rxPkt.hdr.id);

				is_comm_copy_to_struct(&dataWritten, &comm, sizeof(uDatasets));

				EXPECT_EQ((int)td.did, (int)comm.rxPkt.hdr.id);
				break;

			case _PTYPE_UBLOX:	DEBUG_PRINTF("[%d] (%d) Good %d: Ublox\n", found, comm.rxPkt.data.size, g_comm.rxPktCount);		break;
			case _PTYPE_RTCM3:	DEBUG_PRINTF("[%d] (%d) Good %d: RTCM3\n", found, comm.rxPkt.data.size, g_comm.rxPktCount);		break;
			case _PTYPE_SONY: 	DEBUG_PRINTF("[%d] (%d) Good %d: Sony\n",  found, comm.rxPkt.data.size, g_comm.rxPktCount);		break;

			case _PTYPE_NMEA:
				DEBUG_PRINTF("[%d] (%d) Good %d ", found, comm.rxPkt.data.size, g_comm.rxPktCount);
				printNmeaMessage("Found data", comm.rxPkt.data.ptr, comm.rxPkt.data.size);
				break;
			}

			if (ptype != _PTYPE_PARSE_ERROR)
			{
				EXPECT_EQ(td.size, comm.rxPkt.data.size);
				EXPECT_TRUE(memcmp(td.data.buf, comm.rxPkt.data.ptr, td.size) == 0);
				priorBad = false;
			}
			else
			{
				DEBUG_PRINTF("[%d] (%d) Bad  %d\n", found, 0, g_comm.rxErrorCount);
				priorBad = true;
			}

			found++;
		}

		if (ringBufUsed(&tcm.portTxBuf)<=0)
		{
			// No more data left in ring buffer.  Reset parser one byte ahead of head and try again until there's no more data iscomm buffer.
			comm.rxBuf.head++;
			is_comm_reset_parser(&comm);

			if (comm.rxBuf.head >= comm.rxBuf.tail)
			{	// No more data to parse. 
				break;
			}
		}
	}

	// Check that we got all data
	EXPECT_TRUE(ringBufUsed(&tcm.portTxBuf) == 0);
	EXPECT_TRUE(g_testTxDeque.empty());

	// Check good and bad packet count
	EXPECT_EQ(g_comm.rxPktCount, goodPktCount);
	EXPECT_EQ(g_comm.rxErrorCount, badPktCount);
}
#endif


#if TEST_BUFF_PARSE_MSG

#define BUFF_PARSE_PASSES		1000000
#define BUFF_PARSE_OUT_BUF_SIZE 600  
#define BUFF_PARSE_DEV          0  
#define BUFF_PARSE_DEV_NMEA     1  
#define BUFF_PARSE_GPS          2  
#define BUFF_PARSE_IMU          3  
#define BUFF_PARSE_INS          4  

static uint32_t s_buffParseMsgInCnt[5] = { 0 };

/**
 * @brief ISB callback for testing the function is_comm_buffer_parse_messages()
 */
int BufferParse_isb(unsigned int port, p_data_t* data)
{
    switch (data->hdr.id)
    {
        case DID_DEV_INFO:  s_buffParseMsgInCnt[BUFF_PARSE_DEV]++;  break;
        case DID_INS_2:     s_buffParseMsgInCnt[BUFF_PARSE_INS]++;  break;
        case DID_GPS1_POS:  s_buffParseMsgInCnt[BUFF_PARSE_GPS]++;  break;
        case DID_IMU:       s_buffParseMsgInCnt[BUFF_PARSE_IMU]++;  break;
    }

    return 0;
}

/**
 * @brief NMEA callback for testing the function is_comm_buffer_parse_messages()
 */
int BufferParse_nmea(unsigned int port, const unsigned char* msg, int msgSize)
{
	switch (getNmeaMsgId(msg, msgSize))
    {
        case NMEA_MSG_ID_INFO:  s_buffParseMsgInCnt[BUFF_PARSE_DEV_NMEA]++;  break;
    }
    return 0;
}

/**
 * @brief Tests and exercises the function is_comm_buffer_parse_messages()
 */
TEST(ISComm, BufferParse)
{
    is_comm_instance_t comm;

    is_comm_callbacks_t callbacks = {};
    callbacks.isbData = BufferParse_isb;
    callbacks.nmea = BufferParse_nmea;

    uint32_t msgOutCnt[5] = {0};

    uint8_t tmpBuf[BUFF_PARSE_OUT_BUF_SIZE] = {0};
    uint8_t outBuf[BUFF_PARSE_OUT_BUF_SIZE] = {0};
    uint8_t commBuf[2048] = {0};

    uint32_t outBufSize = 0;
    uint32_t tmpBufSize = 0;
	uint32_t totalBytes = 0;

    // create comm instance
    is_comm_init(&comm, commBuf, sizeof(commBuf));

    // Enable/disable protocols
    g_comm.config.enabledMask = 0;
    g_comm.config.enabledMask |= (uint32_t)(ENABLE_PROTOCOL_ISB    * TEST_PROTO_ISB);
    g_comm.config.enabledMask |= (uint32_t)(ENABLE_PROTOCOL_NMEA   * TEST_PROTO_NMEA);
    

    // Load com buffer BUFF_PARSE_PASSES times
    for (int i = 0; i < BUFF_PARSE_PASSES; i++)
    {
        memset(outBuf, 0, sizeof(outBuf));
        outBufSize = 0;

        while (outBufSize < BUFF_PARSE_OUT_BUF_SIZE)
        {
            for (int j = 0; j < tmpBufSize; j++)
            {
                outBuf[outBufSize] = tmpBuf[j];
                outBufSize++;
                if (outBufSize >= BUFF_PARSE_OUT_BUF_SIZE)
                {  
                    tmpBufSize = tmpBufSize - (j+1);
                    memmove(tmpBuf, &tmpBuf[j+1], tmpBufSize);
                    break;
                }
            }

            if (outBufSize >= BUFF_PARSE_OUT_BUF_SIZE)  
                break;

			// prep for next message
			uint8_t randByte = (uint8_t)rand();
            memset(tmpBuf, 0, BUFF_PARSE_OUT_BUF_SIZE);

            // fill next read
            switch (randByte&0x7)
            {
                case BUFF_PARSE_DEV: // Dev Info
					tmpBufSize = generate_ISBPkt_DevInfo(&comm, tmpBuf, BUFF_PARSE_OUT_BUF_SIZE);
                    msgOutCnt[BUFF_PARSE_DEV]++;
                    break;
                case BUFF_PARSE_DEV_NMEA: // Dev Info NMEA
					tmpBufSize = generate_NMEAPkt_DevInfo(&comm, tmpBuf, BUFF_PARSE_OUT_BUF_SIZE);
                    msgOutCnt[BUFF_PARSE_DEV_NMEA]++;
                    break;
                case BUFF_PARSE_GPS: // GPS
                    tmpBufSize = generate_ISBPkt_gps1Pos(&comm, tmpBuf, BUFF_PARSE_OUT_BUF_SIZE);
                    msgOutCnt[BUFF_PARSE_GPS]++;
                    break;
                case BUFF_PARSE_IMU: // IMU
                    tmpBufSize = generate_ISBPkt_imu(&comm, tmpBuf, BUFF_PARSE_OUT_BUF_SIZE);
                    msgOutCnt[BUFF_PARSE_IMU]++;
                    break;
                case BUFF_PARSE_INS: // INS
                    tmpBufSize = generate_ISBPkt_ins2(&comm, tmpBuf, BUFF_PARSE_OUT_BUF_SIZE);
                    msgOutCnt[BUFF_PARSE_INS]++;
                    break;
                case 5: // 0's up to 15
                    tmpBufSize = ((randByte&0xf0) >> 4);
                    break;
                case 6: // 0's up to 63
                    tmpBufSize = ((randByte&0x7e) >> 1);
                    break;
                default: // fill with upto 64 random values
				{
					tmpBufSize = ((randByte & 0xfc) >> 2);
					
					for (int j = 0; j < tmpBufSize; j++)
					{
						tmpBuf[j] = (uint8_t)rand();

						// CHEAT A LITTLE. Dont allow packet start bytes.
						if (tmpBuf[j] == PSC_NMEA_START_BYTE ||
							tmpBuf[j] == PSC_ISB_PREAMBLE_BYTE1 ||
							tmpBuf[j] == UBLOX_START_BYTE1 ||
							tmpBuf[j] == RTCM3_START_BYTE ||
							tmpBuf[j] == SPARTN_START_BYTE ||
							tmpBuf[j] == SONY_START_BYTE)
						{
							tmpBuf[j] = 0x00;
						}
					}

					break;
				}
            }
        }

        // load current batch into comm buffer
        is_comm_buffer_parse_messages(outBuf, outBufSize, &comm, &callbacks);
        totalBytes += outBufSize;
    }

    // load any remaining bytes into comm buffer
    outBufSize = 0;
    for (int j = 0; j < tmpBufSize; j++)
    {
        outBuf[outBufSize] = tmpBuf[j];
        outBufSize++;
    }

    is_comm_buffer_parse_messages(outBuf, outBufSize, &comm, &callbacks);
    totalBytes += outBufSize;  

    // print stats
    #if TEST_STATS_FOR_NERDS
        printf("Bytes parsed: %d\r\n", totalBytes);
        printf("DID_DEV_INFO: outCnt: %d, inCnt: %d\r\n", msgOutCnt[BUFF_PARSE_DEV], s_buffParseMsgInCnt[BUFF_PARSE_DEV]);
        printf("NMEA_DEV_INFO: outCnt: %d, inCnt: %d\r\n", msgOutCnt[BUFF_PARSE_DEV_NMEA], s_buffParseMsgInCnt[BUFF_PARSE_DEV_NMEA]);
        printf("DID_GPS1_POS: outCnt: %d, inCnt: %d\r\n", msgOutCnt[BUFF_PARSE_GPS], s_buffParseMsgInCnt[BUFF_PARSE_GPS]);
        printf("DID_IMU: outCnt: %d, inCnt: %d\r\n", msgOutCnt[BUFF_PARSE_IMU], s_buffParseMsgInCnt[BUFF_PARSE_IMU]);
        printf("DID_INS: outCnt: %d, inCnt: %d\r\n", msgOutCnt[BUFF_PARSE_INS], s_buffParseMsgInCnt[BUFF_PARSE_INS]);
    #endif

    // Check good and bad packet count
    EXPECT_EQ(msgOutCnt[BUFF_PARSE_DEV], s_buffParseMsgInCnt[BUFF_PARSE_DEV]);
    EXPECT_EQ(msgOutCnt[BUFF_PARSE_DEV_NMEA], s_buffParseMsgInCnt[BUFF_PARSE_DEV_NMEA]);
    EXPECT_EQ(msgOutCnt[BUFF_PARSE_GPS], s_buffParseMsgInCnt[BUFF_PARSE_GPS]);
    EXPECT_EQ(msgOutCnt[BUFF_PARSE_IMU], s_buffParseMsgInCnt[BUFF_PARSE_IMU]);
    EXPECT_EQ(msgOutCnt[BUFF_PARSE_INS], s_buffParseMsgInCnt[BUFF_PARSE_INS]);
}
#endif



